<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Aula3</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Mariana Rocha &lt;a90817@alunos.uminho.pt&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Aula3</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Este m&#243;dulo cont&#233;m defini&#231;&#245;es Haskell para o c&#225;lculo de fun&#231;&#245;es
recursivas simples.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:deslocad">deslocad</a> :: [a] -&gt; Int -&gt; [a]</li><li class="src short"><a href="#v:deslocae">deslocae</a> :: [a] -&gt; Int -&gt; [a]</li><li class="src short"><a href="#v:trocalinhas">trocalinhas</a> :: [[a]] -&gt; [[a]]</li><li class="src short"><a href="#v:trocacolunas">trocacolunas</a> :: [[a]] -&gt; [[a]]</li><li class="src short"><a href="#v:posicao-39-">posicao'</a> :: Eq a =&gt; Int -&gt; a -&gt; [a] -&gt; Int</li><li class="src short"><a href="#v:posicao">posicao</a> :: Eq a =&gt; a -&gt; [a] -&gt; Int</li><li class="src short"><a href="#v:subs">subs</a> :: Eq a =&gt; [a] -&gt; Int -&gt; a -&gt; [a]</li><li class="src short"><a href="#v:encM-39-">encM'</a> :: Eq a =&gt; (Int, Int) -&gt; a -&gt; [[a]] -&gt; (Int, Int)</li><li class="src short"><a href="#v:encM">encM</a> :: Eq a =&gt; a -&gt; [[a]] -&gt; (Int, Int)</li><li class="src short"><a href="#v:subsM">subsM</a> :: Eq a =&gt; (Int, Int) -&gt; a -&gt; [[a]] -&gt; [[a]]</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:deslocad" class="def">deslocad</a> <a href="#v:deslocad" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [a]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>argumentos: uma lista e um inteiro (n&#227;o negativo)</p></td></tr><tr><td class="src">-&gt; [a]</td><td class="doc"><p>resultado: uma lista</p></td></tr></table></div><div class="doc"><p>Dada uma lista l e um n&#250;mero inteiro a, a fun&#231;&#227;o &#180;descolad&#180; desloca cada elemento da lista a posi&#231;&#245;es para a direita.</p><p>A fun&#231;&#227;o poderia ser definida da seguinte forma:</p><pre>deslocad :: [a] -&gt; Int -&gt; a
deslocad [] _ = []
deslocad l a | a == 1 = [last l] ++ (init l)
             | otherwise = (deslocad ([last l] ++ (init l)) (a-1))
</pre><h2>Exemplos de utiliza&#231;&#227;o:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>deslocad [1,2,3,4,5] 2
</code></strong>[4,5,1,2,3]
</pre></div></div><div class="top"><p class="src"><a id="v:deslocae" class="def">deslocae</a> <a href="#v:deslocae" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [a]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>argumentos: uma lista e um inteiro (n&#227;o negativo)</p></td></tr><tr><td class="src">-&gt; [a]</td><td class="doc"><p>resultado: uma lista</p></td></tr></table></div><div class="doc"><p>Dada uma lista l e um n&#250;mero inteiro a, a fun&#231;&#227;o &#180;descolae&#180; desloca cada elemento da lista a posi&#231;&#245;es para a esquerda.</p><p>A fun&#231;&#227;o poderia ser definida da seguinte forma:</p><pre>deslocae :: [a] -&gt; Int -&gt; [a]
deslocae [] _ = []
deslocae (h:t) a | a == 0 = t ++ [h]
                 | otherwise = (deslocae (t ++ [h]) (a-1))
</pre><h2>Exemplos de utiliza&#231;&#227;o:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>deslocae [1,2,3,4,5] 2
</code></strong>[4,5,1,2,3]
</pre></div></div><div class="top"><p class="src"><a id="v:trocalinhas" class="def">trocalinhas</a> <a href="#v:trocalinhas" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [[a]]</td><td class="doc"><p>argumento: uma matriz</p></td></tr><tr><td class="src">-&gt; [[a]]</td><td class="doc"><p>resultado: uma matriz</p></td></tr></table></div><div class="doc"><p>Dada uma matriz l, a fun&#231;&#227;o &#180;trocalinhas&#180; troca a primeira linha com a &#250;ltima.</p><p>A fun&#231;&#227;o poderia ser definida da seguinte forma:</p><pre>trocalinhas :: [[a]] -&gt; [[a]]
trocalinhas l = [(last l)] ++ tail(init l) ++ [(head l)]
</pre><h2>Exemplos de utiliza&#231;&#227;o:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>trocalinhas [[1,2],[3,4],[5,6],[7,8]]
</code></strong>[[7,8],[3,4],[5,6],[1,2]]
</pre></div></div><div class="top"><p class="src"><a id="v:trocacolunas" class="def">trocacolunas</a> <a href="#v:trocacolunas" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [[a]]</td><td class="doc"><p>argumento: uma matriz</p></td></tr><tr><td class="src">-&gt; [[a]]</td><td class="doc"><p>resultado: uma matriz</p></td></tr></table></div><div class="doc"><p>Dada uma matriz l, a fun&#231;&#227;o &#180;trocacolunas&#180; troca a primeira coluna com a &#250;ltima.</p><p>A fun&#231;&#227;o poderia ser definida da seguinte forma:</p><pre>trocacolunas :: [[a]] -&gt; [[a]]
trocacolunas [] = []
trocacolunas (h:t) = ([(last h)] ++ init (tail h) ++ (init h)) : trocacolunas t
</pre><h2>Exemplos de utiliza&#231;&#227;o:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>trocacolunas [[1,2],[3,4],[5,6],[7,8]]
</code></strong>[[2,1],[4,3],[6,5],[8,7]]
</pre></div></div><div class="top"><p class="src"><a id="v:posicao-39-" class="def">posicao'</a> :: Eq a =&gt; Int -&gt; a -&gt; [a] -&gt; Int <a href="#v:posicao-39-" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o &#180;posicao'&#180; &#233; uma fun&#231;&#227;o auxiliar da fun&#231;&#227;o &#180;posicao&#180; que tamb&#233;m recebe por quantos elementos j&#225; passou.
Quando verifica que o elemento n&#227;o &#233; o pretendido, chama-se a si pr&#243;pria, mas incrementando um acumulador.</p><p>A fun&#231;&#227;o poderia ser definida da seguinte forma:</p><pre>posicao' :: Eq a =&gt; Int -&gt; a -&gt; [a] -&gt; Int
posicao' _ _ [] = -1
posicao' i a (h:t) | h == a = i
                   | otherwise = posicao' (i+1) a t
</pre></div></div><div class="top"><p class="src"><a id="v:posicao" class="def">posicao</a> <a href="#v:posicao" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Eq a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; [a]</td><td class="doc"><p>argumentos: um elemento da lista e a lista</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>resultado: posi&#231;&#227;o do elemento</p></td></tr></table></div><div class="doc"><p>A fun&#231;&#227;o &#180;posicao&#180;, com o aux&#237;lio da fun&#231;&#227;o &#180;posicao'&#180;, procura a posi&#231;&#227;o de um elemento numa dada lista retornando apenas a primeira ocorr&#234;ncia.
Caso o elemento n&#227;o ocorra na lista a fun&#231;&#227;o devolve o n&#250;mero inteiro -1.</p><p>A fun&#231;&#227;o poderia ser definida da seguinte forma:</p><pre>posicao :: Eq a =&gt; a -&gt; [a] -&gt; Int
posicao = posicao' 0
</pre><h2>Exemplos de utiliza&#231;&#227;o:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>posicao 2 [3,4,5]
</code></strong>-1
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>posicao 2 [3,4,5,2]
</code></strong>3
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>posicao 2 [32,2,4,5,2]
</code></strong>1
</pre></div></div><div class="top"><p class="src"><a id="v:subs" class="def">subs</a> <a href="#v:subs" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Eq a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; [a]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; Int</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>argumentos: uma lista, a posi&#231;&#227;o da substitui&#231;&#227;o e valor dado</p></td></tr><tr><td class="src">-&gt; [a]</td><td class="doc"><p>resultado: uma lista</p></td></tr></table></div><div class="doc"><p>A fun&#231;&#227;o &#180;subs&#180; ir&#225; receber uma lista, uma certa posi&#231;&#227;o e um elemento. Esta substitui o elemento na posi&#231;&#227;o dada na lista.
Caso o valor da posi&#231;&#227;o dada for superior ao tamanho da lista, a fun&#231;&#227;o ir&#225; retornar a lista. </p><p>A fun&#231;&#227;o poderia ser definida da seguinte forma:</p><pre>subs :: Eq a =&gt; [a] -&gt; Int -&gt; a -&gt; [a]
subs [] _ _ = []
subs l pos elemento | length l &lt; pos = l
                    | pos == 0 = [elemento] ++ (tail l)
                    | otherwise = (take (pos-1) l) ++ [elemento] ++ (drop pos l)
</pre><h2>Exemplos de utiliza&#231;&#227;o:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>subs &quot;ola&quot; 0 'O'
</code></strong>&quot;Ola&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>subs [1,2,3,4] 2 5
</code></strong>[1,5,3,4]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>subs [1,2,3,4] 5 6
</code></strong>[1,2,3,4]
</pre></div></div><div class="top"><p class="src"><a id="v:encM-39-" class="def">encM'</a> :: Eq a =&gt; (Int, Int) -&gt; a -&gt; [[a]] -&gt; (Int, Int) <a href="#v:encM-39-" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o &#180;encM'&#180; &#233; uma fun&#231;&#227;o auxiliar da fun&#231;&#227;o &#180;encM&#180; que tamb&#233;m recebe por quantos elementos j&#225; passou.
Quando verifica que o elemento n&#227;o &#233; o pretendido, chama-se a si pr&#243;pria, mas incrementando um acumulador.</p><p>A fun&#231;&#227;o poderia ser definida da seguinte forma:</p><pre>encM' :: Eq a =&gt; (Int,Int) -&gt; a -&gt; [[a]] -&gt; (Int,Int)
encM' _ _ [] = (-1,-1)
encM' (i,j) a (h:t) | posicao a h == -1 = encM' (i+1,0) a t
                    | otherwise = (i,j+ posicao a h)
</pre></div></div><div class="top"><p class="src"><a id="v:encM" class="def">encM</a> <a href="#v:encM" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Eq a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; [[a]]</td><td class="doc"><p>argumentos: elemento, uma matriz</p></td></tr><tr><td class="src">-&gt; (Int, Int)</td><td class="doc"><p>resultado: posi&#231;&#227;o do elemento</p></td></tr></table></div><div class="doc"><p>A fun&#231;&#227;o recursiva &#180;encM&#180;, com o aux&#237;lio da fun&#231;&#227;o &#180;encM'&#180;, ir&#225; encontrar a primeira ocorr&#234;ncia de um dado elemento numa matriz. </p><p>A fun&#231;&#227;o poderia ser definida da seguinte forma:</p><pre>encM :: Eq a =&gt; a -&gt; [[a]] -&gt; (Int,Int)
encM = encM' (0,0)
</pre><h2>Exemplos de utiliza&#231;&#227;o:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>encM 2 [[1,2],[3,4],[5,6],[7,8]]
</code></strong>(0,1)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>encM 5 [[1,2],[3,4],[5,6],[7,8]]
</code></strong>(2,0)
</pre></div></div><div class="top"><p class="src"><a id="v:subsM" class="def">subsM</a> <a href="#v:subsM" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Eq a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (Int, Int)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; [[a]]</td><td class="doc"><p>argumentos: posi&#231;&#227;o da substitui&#231;&#227;o, valor dado e uma matriz</p></td></tr><tr><td class="src">-&gt; [[a]]</td><td class="doc"><p>resultado: uma matriz</p></td></tr></table></div><div class="doc"><p>A fun&#231;&#227;o recursiva &#180;subsM&#180; substitui um elemento de uma posi&#231;&#227;o fornecida numa matriz, por outro valor.</p><p>A fun&#231;&#227;o poderia ser definida da seguinte forma:</p><pre>subsM :: Eq a =&gt; (Int,Int) -&gt; a -&gt; [[a]] -&gt; [[a]]
subsM _ _ [] = []
subsM (i,j) a (h:t) | i&gt;length (h:t) = (h:t)
                    | i == 0 = (subs h j a:t)
                    | otherwise = h:(subsM (i-1,j) a t)
</pre><h2>Exemplos de utiliza&#231;&#227;o:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>subsM (4,1) 2 [[1,2],[3,4],[5,6],[7,8]]
</code></strong>[[1,2],[3,4],[5,6],[7,8]]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>subsM (3,1) 2 [[1,2],[3,4],[5,6],[7,8]]
</code></strong>[[1,2],[3,4],[5,6],[2,8]]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>subsM (2,0) 2 [[1,2],[3,4],[5,6],[7,8]]
</code></strong>[[1,2],[3,4],[2,6],[7,8]]
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>